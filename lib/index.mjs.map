{"version":3,"sources":["../src/types/content_types.ts","../src/helper/body_parser.ts","../src/helper/header_parser.ts","../src/helper/logger.ts","../src/helper/param_encoder.ts","../src/helper/response_builder.ts","../src/types/methods.ts","../src/fetcher.ts","../src/index.ts"],"sourcesContent":["export const contentTypes = {\n  json: \"application/json\",\n  formData: \"multipart/form-data\",\n  formUrlEncoded: \"application/x-www-form-urlencoded\",\n  textPlain: \"text/plain\",\n} as const;\n\nexport type ContentType = (typeof contentTypes)[keyof typeof contentTypes];\n","import { ContentType, contentTypes } from \"../types/content_types\";\n\n// Optimize formUrlEncoded for performance\nconst formUrlEncoded = (jsonBody: Record<string, any>): URLSearchParams => {\n  const params = new URLSearchParams();\n\n  // Use faster for...in with direct type checking\n  for (const key in jsonBody) {\n    // More efficient property check\n    if (Object.prototype.hasOwnProperty.call(jsonBody, key)) {\n      const value = jsonBody[key];\n\n      // Handle different value types more robustly\n      if (value !== null && value !== undefined) {\n        params.append(\n          key,\n          value instanceof Date\n            ? value.toISOString()\n            : value instanceof Array\n            ? JSON.stringify(value)\n            : typeof value === \"object\"\n            ? JSON.stringify(value)\n            : String(value)\n        );\n      }\n    }\n  }\n  return params;\n};\n\nconst bodyParser = ({\n  contentType,\n  jsonBody,\n}: {\n  contentType: ContentType;\n  jsonBody: any;\n}): FormData | string | URLSearchParams | any => {\n  // Early return for null or undefined\n  if (jsonBody === null || jsonBody === undefined) {\n    return jsonBody;\n  }\n\n  // Optimize FormData creation\n  if (contentType === contentTypes.formData) {\n    const formData = new FormData();\n\n    // More efficient form data creation\n    for (const key in jsonBody) {\n      if (Object.prototype.hasOwnProperty.call(jsonBody, key)) {\n        const value = jsonBody[key];\n\n        // Handle array of files\n        if (Array.isArray(value)) {\n          value.forEach((item, index) => {\n            if (item instanceof File || item instanceof Blob) {\n              // Use the same key with multiple values\n              formData.append(key, item);\n            } else if (item !== null && item !== undefined) {\n              formData.append(\n                key,\n                typeof item === \"object\" ? JSON.stringify(item) : String(item)\n              );\n            }\n          });\n        }\n        // Handle single file or other types\n        else if (value instanceof File || value instanceof Blob) {\n          formData.append(key, value);\n        } else if (value instanceof Date) {\n          formData.append(key, value.toISOString());\n        } else if (value !== null && value !== undefined) {\n          formData.append(\n            key,\n            typeof value === \"object\" ? JSON.stringify(value) : String(value)\n          );\n        }\n      }\n    }\n\n    return formData;\n  }\n\n  // Existing switch statement remains the same\n  switch (contentType) {\n    case contentTypes.json:\n      return JSON.stringify(jsonBody);\n    case contentTypes.formUrlEncoded:\n      return formUrlEncoded(jsonBody);\n    case contentTypes.textPlain:\n      return String(jsonBody);\n    default:\n      return jsonBody;\n  }\n};\n\nexport default bodyParser;\n","import { ContentType, contentTypes } from \"../types/content_types\";\n\nconst headersParser = ({\n  jsonHeaders,\n  contentType,\n}: {\n  jsonHeaders?: Record<string, string>;\n  contentType: ContentType;\n}): Headers => {\n  const headers = new Headers();\n\n  // Handle content type setting\n  const effectiveContentType =\n    jsonHeaders?.[\"Content-Type\"] || contentType || contentTypes.json;\n\n  switch (contentType) {\n    case contentTypes.formData:\n      // For FormData, do not set Content-Type\n      break;\n    case contentTypes.json:\n    case contentTypes.formUrlEncoded:\n    case contentTypes.textPlain:\n      headers.set(\"Content-Type\", effectiveContentType);\n      break;\n    default:\n      // For unknown content types, set Content-Type if provided\n      if (effectiveContentType) {\n        headers.set(\"Content-Type\", effectiveContentType);\n      }\n  }\n\n  // Add additional headers\n  if (jsonHeaders) {\n    Object.entries(jsonHeaders).forEach(([key, value]) => {\n      if (key.toLowerCase() !== \"content-type\") {\n        headers.append(key, value);\n      }\n    });\n  }\n\n  return headers;\n};\n\nexport default headersParser;\n","import pino from \"pino\";\n\nconst pino_log = pino(\n  {\n    level: \"trace\", // Set the desired log level\n    timestamp: pino.stdTimeFunctions.isoTime, // Optional: Add timestamp\n    transport: {\n      target: \"pino-pretty\", // Use pino-pretty to format the logs\n      options: {\n        colorize: true, // Enable color output for better visibility in the terminal\n        timestampKey: \"time\", // Customize the timestamp key\n        translateTime: \"SYS:standard\", // Format the timestamp to a readable format\n        ignore: \"pid,hostname\", // Optional: Exclude unnecessary fields\n      },\n    },\n  },\n  process.stdout\n); // Ensure the logs are written to stdout (console)\n\nconst logger = (\n  start: number,\n  method: string,\n  url: string,\n  response: any,\n  requestOptions: RequestInit\n) => {\n  if (response.ok) {\n    pino_log.info(\n      `[${Date.now() - start}ms] [${response.status}] [${method}] - ${url}`\n    );\n  } else {\n    pino_log.error(\n      `[${Date.now() - start}ms] [${response.status}] [${method}] - ${url}`\n    );\n  }\n};\n\nexport default logger;\n","const encodeParams = (params: Record<string, string>): string => {\n  return new URLSearchParams(params).toString();\n};\n\nexport default encodeParams;\n","import { ResponseBody } from \"../types/response_body\";\n\nconst responseBuilder = async (response: Response): Promise<ResponseBody> => {\n  const text = await response.text();\n  try {\n    const json = JSON.parse(text);\n    return {\n      ok: response.ok,\n      status: response.status,\n      statusText: response.statusText,\n      data: json,\n    };\n  } catch (err) {\n    return {\n      ok: response.ok,\n      status: response.status,\n      statusText: response.statusText,\n      data: text,\n    };\n  }\n};\n\nexport default responseBuilder;\n","export const methods = {\n  get: \"GET\",\n  post: \"POST\",\n  put: \"PUT\",\n  delete: \"DELETE\",\n  patch: \"PATCH\",\n  head: \"HEAD\",\n  options: \"OPTIONS\",\n} as const;\n\nexport type Method = (typeof methods)[keyof typeof methods];\n","import bodyParser from \"./helper/body_parser\";\nimport headersParser from \"./helper/header_parser\";\nimport logger from \"./helper/logger\";\nimport encodeParams from \"./helper/param_encoder\";\nimport responseBuilder from \"./helper/response_builder\";\nimport { contentTypes } from \"./types/content_types\";\nimport { methods } from \"./types/methods\";\nimport { RequestOptions } from \"./types/request_options\";\nimport { ResponseBody } from \"./types/response_body\";\n\nconst fetchWithTimeout = async (\n  url: string,\n  options: RequestInit,\n  timeout: number\n): Promise<Response> => {\n  const controller = new AbortController();\n  const timer = setTimeout(() => controller.abort(), timeout);\n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal,\n    });\n    clearTimeout(timer);\n    return response;\n  } catch (error) {\n    clearTimeout(timer);\n    throw error;\n  }\n};\n\nclass Fetcher {\n  private baseURL: string;\n  private defaultHeaders: Record<string, string>;\n  private logging: boolean;\n\n  constructor({\n    baseURL = \"\",\n    defaultHeaders = {},\n    logging = false,\n  }: {\n    baseURL?: string;\n    defaultHeaders?: Record<string, string>;\n    logging?: boolean;\n  } = {}) {\n    this.baseURL = baseURL;\n    this.defaultHeaders = defaultHeaders;\n    this.logging = logging;\n  }\n\n  async request({\n    method = methods.get,\n    url,\n    contentType = contentTypes.json,\n    headers = {},\n    params,\n    body,\n    timeout = 10000,\n  }: RequestOptions): Promise<ResponseBody> {\n    const finalUrl = this.baseURL + url;\n    const combinedHeaders = { ...this.defaultHeaders, ...headers };\n\n    let requestOptions: RequestInit = {\n      method,\n      headers: headersParser({ jsonHeaders: combinedHeaders, contentType }),\n      redirect: \"follow\",\n    };\n\n    if (params) {\n      const encodedParams = encodeParams(params);\n      url = `${finalUrl}?${encodedParams}`;\n    }\n\n    if (body) {\n      requestOptions.body = bodyParser({\n        contentType,\n        jsonBody: body,\n      });\n    }\n\n    const start = Date.now();\n\n    try {\n      const response = await fetchWithTimeout(\n        finalUrl,\n        requestOptions,\n        timeout\n      );\n\n      if (this.logging) {\n        logger(start, method, finalUrl, response, requestOptions);\n      }\n\n      if (response.ok) {\n        return await responseBuilder(response);\n      } else {\n        throw await responseBuilder(response);\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async get({\n    url,\n    contentType = contentTypes.json,\n    headers = {},\n    params,\n    timeout = 10000,\n  }: RequestOptions): Promise<ResponseBody> {\n    return this.request({\n      method: methods.get,\n      url,\n      contentType,\n      headers,\n      params,\n      timeout,\n    });\n  }\n\n  async post({\n    url,\n    contentType = contentTypes.json,\n    headers = {},\n    params,\n    body,\n    timeout = 10000,\n  }: RequestOptions): Promise<ResponseBody> {\n    return this.request({\n      method: methods.post,\n      url,\n      contentType,\n      headers,\n      params,\n      body,\n      timeout,\n    });\n  }\n\n  async put({\n    url,\n    contentType = contentTypes.json,\n    headers = {},\n    params,\n    body,\n    timeout = 10000,\n  }: RequestOptions): Promise<ResponseBody> {\n    return this.request({\n      method: methods.put,\n      url,\n      contentType,\n      headers,\n      params,\n      body,\n      timeout,\n    });\n  }\n\n  async delete({\n    url,\n    contentType = contentTypes.json,\n    headers = {},\n    params,\n    body,\n    timeout = 10000,\n  }: RequestOptions): Promise<ResponseBody> {\n    return this.request({\n      method: methods.delete,\n      url,\n      contentType,\n      headers,\n      params,\n      body,\n      timeout,\n    });\n  }\n\n  async patch({\n    url,\n    contentType = contentTypes.json,\n    headers = {},\n    params,\n    body,\n    timeout = 10000,\n  }: RequestOptions): Promise<ResponseBody> {\n    return this.request({\n      method: methods.patch,\n      url,\n      contentType,\n      headers,\n      params,\n      body,\n      timeout,\n    });\n  }\n\n  async head({\n    url,\n    contentType = contentTypes.json,\n    headers = {},\n    params,\n    timeout = 10000,\n  }: RequestOptions): Promise<ResponseBody> {\n    return this.request({\n      method: methods.head,\n      url,\n      contentType,\n      headers,\n      params,\n      timeout,\n    });\n  }\n\n  async options({\n    url,\n    contentType = contentTypes.json,\n    headers = {},\n    params,\n    timeout = 10000,\n  }: RequestOptions): Promise<ResponseBody> {\n    return this.request({\n      method: methods.options,\n      url,\n      contentType,\n      headers,\n      params,\n      timeout,\n    });\n  }\n}\n\nexport default Fetcher;\n","import Fetcher from \"./fetcher\";\nimport { contentTypes } from \"./types/content_types\";\nimport { methods } from \"./types/methods\";\n\nconst fetcher = {\n  Fetcher,\n  contentTypes,\n  methods,\n};\n\nexport default fetcher;\nexport { contentTypes, Fetcher, methods };\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,IAAM,eAAe;AAAA,EAC1B,MAAM;AAAA,EACN,UAAU;AAAA,EACV,gBAAgB;AAAA,EAChB,WAAW;AACb;;;ACFA,IAAM,iBAAiB,CAAC,aAAmD;AACzE,QAAM,SAAS,IAAI,gBAAgB;AAGnC,aAAW,OAAO,UAAU;AAE1B,QAAI,OAAO,UAAU,eAAe,KAAK,UAAU,GAAG,GAAG;AACvD,YAAM,QAAQ,SAAS,GAAG;AAG1B,UAAI,UAAU,QAAQ,UAAU,QAAW;AACzC,eAAO;AAAA,UACL;AAAA,UACA,iBAAiB,OACb,MAAM,YAAY,IAClB,iBAAiB,QACjB,KAAK,UAAU,KAAK,IACpB,OAAO,UAAU,WACjB,KAAK,UAAU,KAAK,IACpB,OAAO,KAAK;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEA,IAAM,aAAa,CAAC;AAAA,EAClB;AAAA,EACA;AACF,MAGiD;AAE/C,MAAI,aAAa,QAAQ,aAAa,QAAW;AAC/C,WAAO;AAAA,EACT;AAGA,MAAI,gBAAgB,aAAa,UAAU;AACzC,UAAM,WAAW,IAAI,SAAS;AAG9B,eAAW,OAAO,UAAU;AAC1B,UAAI,OAAO,UAAU,eAAe,KAAK,UAAU,GAAG,GAAG;AACvD,cAAM,QAAQ,SAAS,GAAG;AAG1B,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAM,QAAQ,CAAC,MAAM,UAAU;AAC7B,gBAAI,gBAAgB,QAAQ,gBAAgB,MAAM;AAEhD,uBAAS,OAAO,KAAK,IAAI;AAAA,YAC3B,WAAW,SAAS,QAAQ,SAAS,QAAW;AAC9C,uBAAS;AAAA,gBACP;AAAA,gBACA,OAAO,SAAS,WAAW,KAAK,UAAU,IAAI,IAAI,OAAO,IAAI;AAAA,cAC/D;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH,WAES,iBAAiB,QAAQ,iBAAiB,MAAM;AACvD,mBAAS,OAAO,KAAK,KAAK;AAAA,QAC5B,WAAW,iBAAiB,MAAM;AAChC,mBAAS,OAAO,KAAK,MAAM,YAAY,CAAC;AAAA,QAC1C,WAAW,UAAU,QAAQ,UAAU,QAAW;AAChD,mBAAS;AAAA,YACP;AAAA,YACA,OAAO,UAAU,WAAW,KAAK,UAAU,KAAK,IAAI,OAAO,KAAK;AAAA,UAClE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAGA,UAAQ,aAAa;AAAA,IACnB,KAAK,aAAa;AAChB,aAAO,KAAK,UAAU,QAAQ;AAAA,IAChC,KAAK,aAAa;AAChB,aAAO,eAAe,QAAQ;AAAA,IAChC,KAAK,aAAa;AAChB,aAAO,OAAO,QAAQ;AAAA,IACxB;AACE,aAAO;AAAA,EACX;AACF;AAEA,IAAO,sBAAQ;;;AC7Ff,IAAM,gBAAgB,CAAC;AAAA,EACrB;AAAA,EACA;AACF,MAGe;AACb,QAAM,UAAU,IAAI,QAAQ;AAG5B,QAAM,wBACJ,2CAAc,oBAAmB,eAAe,aAAa;AAE/D,UAAQ,aAAa;AAAA,IACnB,KAAK,aAAa;AAEhB;AAAA,IACF,KAAK,aAAa;AAAA,IAClB,KAAK,aAAa;AAAA,IAClB,KAAK,aAAa;AAChB,cAAQ,IAAI,gBAAgB,oBAAoB;AAChD;AAAA,IACF;AAEE,UAAI,sBAAsB;AACxB,gBAAQ,IAAI,gBAAgB,oBAAoB;AAAA,MAClD;AAAA,EACJ;AAGA,MAAI,aAAa;AACf,WAAO,QAAQ,WAAW,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,UAAI,IAAI,YAAY,MAAM,gBAAgB;AACxC,gBAAQ,OAAO,KAAK,KAAK;AAAA,MAC3B;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEA,IAAO,wBAAQ;;;AC3Cf,OAAO,UAAU;AAEjB,IAAM,WAAW;AAAA,EACf;AAAA,IACE,OAAO;AAAA;AAAA,IACP,WAAW,KAAK,iBAAiB;AAAA;AAAA,IACjC,WAAW;AAAA,MACT,QAAQ;AAAA;AAAA,MACR,SAAS;AAAA,QACP,UAAU;AAAA;AAAA,QACV,cAAc;AAAA;AAAA,QACd,eAAe;AAAA;AAAA,QACf,QAAQ;AAAA;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAAA,EACA,QAAQ;AACV;AAEA,IAAM,SAAS,CACb,OACA,QACA,KACA,UACA,mBACG;AACH,MAAI,SAAS,IAAI;AACf,aAAS;AAAA,MACP,IAAI,KAAK,IAAI,IAAI,KAAK,QAAQ,SAAS,MAAM,MAAM,MAAM,OAAO,GAAG;AAAA,IACrE;AAAA,EACF,OAAO;AACL,aAAS;AAAA,MACP,IAAI,KAAK,IAAI,IAAI,KAAK,QAAQ,SAAS,MAAM,MAAM,MAAM,OAAO,GAAG;AAAA,IACrE;AAAA,EACF;AACF;AAEA,IAAO,iBAAQ;;;ACrCf,IAAM,eAAe,CAAC,WAA2C;AAC/D,SAAO,IAAI,gBAAgB,MAAM,EAAE,SAAS;AAC9C;AAEA,IAAO,wBAAQ;;;ACFf,IAAM,kBAAkB,CAAO,aAA8C;AAC3E,QAAM,OAAO,MAAM,SAAS,KAAK;AACjC,MAAI;AACF,UAAM,OAAO,KAAK,MAAM,IAAI;AAC5B,WAAO;AAAA,MACL,IAAI,SAAS;AAAA,MACb,QAAQ,SAAS;AAAA,MACjB,YAAY,SAAS;AAAA,MACrB,MAAM;AAAA,IACR;AAAA,EACF,SAAS,KAAK;AACZ,WAAO;AAAA,MACL,IAAI,SAAS;AAAA,MACb,QAAQ,SAAS;AAAA,MACjB,YAAY,SAAS;AAAA,MACrB,MAAM;AAAA,IACR;AAAA,EACF;AACF;AAEA,IAAO,2BAAQ;;;ACtBR,IAAM,UAAU;AAAA,EACrB,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,SAAS;AACX;;;ACEA,IAAM,mBAAmB,CACvB,KACA,SACA,YACsB;AACtB,QAAM,aAAa,IAAI,gBAAgB;AACvC,QAAM,QAAQ,WAAW,MAAM,WAAW,MAAM,GAAG,OAAO;AAC1D,MAAI;AACF,UAAM,WAAW,MAAM,MAAM,KAAK,iCAC7B,UAD6B;AAAA,MAEhC,QAAQ,WAAW;AAAA,IACrB,EAAC;AACD,iBAAa,KAAK;AAClB,WAAO;AAAA,EACT,SAAS,OAAO;AACd,iBAAa,KAAK;AAClB,UAAM;AAAA,EACR;AACF;AAEA,IAAM,UAAN,MAAc;AAAA,EAKZ,YAAY;AAAA,IACV,UAAU;AAAA,IACV,iBAAiB,CAAC;AAAA,IAClB,UAAU;AAAA,EACZ,IAII,CAAC,GAAG;AACN,SAAK,UAAU;AACf,SAAK,iBAAiB;AACtB,SAAK,UAAU;AAAA,EACjB;AAAA,EAEM,QAAQ,IAQ4B;AAAA,+CAR5B;AAAA,MACZ,SAAS,QAAQ;AAAA,MACjB;AAAA,MACA,cAAc,aAAa;AAAA,MAC3B,UAAU,CAAC;AAAA,MACX;AAAA,MACA;AAAA,MACA,UAAU;AAAA,IACZ,GAA0C;AACxC,YAAM,WAAW,KAAK,UAAU;AAChC,YAAM,kBAAkB,kCAAK,KAAK,iBAAmB;AAErD,UAAI,iBAA8B;AAAA,QAChC;AAAA,QACA,SAAS,sBAAc,EAAE,aAAa,iBAAiB,YAAY,CAAC;AAAA,QACpE,UAAU;AAAA,MACZ;AAEA,UAAI,QAAQ;AACV,cAAM,gBAAgB,sBAAa,MAAM;AACzC,cAAM,GAAG,QAAQ,IAAI,aAAa;AAAA,MACpC;AAEA,UAAI,MAAM;AACR,uBAAe,OAAO,oBAAW;AAAA,UAC/B;AAAA,UACA,UAAU;AAAA,QACZ,CAAC;AAAA,MACH;AAEA,YAAM,QAAQ,KAAK,IAAI;AAEvB,UAAI;AACF,cAAM,WAAW,MAAM;AAAA,UACrB;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAEA,YAAI,KAAK,SAAS;AAChB,yBAAO,OAAO,QAAQ,UAAU,UAAU,cAAc;AAAA,QAC1D;AAEA,YAAI,SAAS,IAAI;AACf,iBAAO,MAAM,yBAAgB,QAAQ;AAAA,QACvC,OAAO;AACL,gBAAM,MAAM,yBAAgB,QAAQ;AAAA,QACtC;AAAA,MACF,SAAS,OAAO;AACd,cAAM;AAAA,MACR;AAAA,IACF;AAAA;AAAA,EAEM,IAAI,IAMgC;AAAA,+CANhC;AAAA,MACR;AAAA,MACA,cAAc,aAAa;AAAA,MAC3B,UAAU,CAAC;AAAA,MACX;AAAA,MACA,UAAU;AAAA,IACZ,GAA0C;AACxC,aAAO,KAAK,QAAQ;AAAA,QAClB,QAAQ,QAAQ;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA;AAAA,EAEM,KAAK,IAO+B;AAAA,+CAP/B;AAAA,MACT;AAAA,MACA,cAAc,aAAa;AAAA,MAC3B,UAAU,CAAC;AAAA,MACX;AAAA,MACA;AAAA,MACA,UAAU;AAAA,IACZ,GAA0C;AACxC,aAAO,KAAK,QAAQ;AAAA,QAClB,QAAQ,QAAQ;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA;AAAA,EAEM,IAAI,IAOgC;AAAA,+CAPhC;AAAA,MACR;AAAA,MACA,cAAc,aAAa;AAAA,MAC3B,UAAU,CAAC;AAAA,MACX;AAAA,MACA;AAAA,MACA,UAAU;AAAA,IACZ,GAA0C;AACxC,aAAO,KAAK,QAAQ;AAAA,QAClB,QAAQ,QAAQ;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA;AAAA,EAEM,OAAO,IAO6B;AAAA,+CAP7B;AAAA,MACX;AAAA,MACA,cAAc,aAAa;AAAA,MAC3B,UAAU,CAAC;AAAA,MACX;AAAA,MACA;AAAA,MACA,UAAU;AAAA,IACZ,GAA0C;AACxC,aAAO,KAAK,QAAQ;AAAA,QAClB,QAAQ,QAAQ;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA;AAAA,EAEM,MAAM,IAO8B;AAAA,+CAP9B;AAAA,MACV;AAAA,MACA,cAAc,aAAa;AAAA,MAC3B,UAAU,CAAC;AAAA,MACX;AAAA,MACA;AAAA,MACA,UAAU;AAAA,IACZ,GAA0C;AACxC,aAAO,KAAK,QAAQ;AAAA,QAClB,QAAQ,QAAQ;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA;AAAA,EAEM,KAAK,IAM+B;AAAA,+CAN/B;AAAA,MACT;AAAA,MACA,cAAc,aAAa;AAAA,MAC3B,UAAU,CAAC;AAAA,MACX;AAAA,MACA,UAAU;AAAA,IACZ,GAA0C;AACxC,aAAO,KAAK,QAAQ;AAAA,QAClB,QAAQ,QAAQ;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA;AAAA,EAEM,QAAQ,IAM4B;AAAA,+CAN5B;AAAA,MACZ;AAAA,MACA,cAAc,aAAa;AAAA,MAC3B,UAAU,CAAC;AAAA,MACX;AAAA,MACA,UAAU;AAAA,IACZ,GAA0C;AACxC,aAAO,KAAK,QAAQ;AAAA,QAClB,QAAQ,QAAQ;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA;AACF;AAEA,IAAO,kBAAQ;;;AClOf,IAAM,UAAU;AAAA,EACd;AAAA,EACA;AAAA,EACA;AACF;AAEA,IAAO,cAAQ;","names":[]}